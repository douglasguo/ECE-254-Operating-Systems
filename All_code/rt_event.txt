; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -ort_event.o --asm_dir=.\ --list_dir=.\ --depend=rt_event.d --cpu=Cortex-M3 --apcs=interwork -O0 -IC:\Software\Keil\ARM\CMSIS\Include -IC:\Software\Keil\ARM\INC\NXP\LPC17xx --omf_browse=rt_event.crf rtx_src\rt_Event.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_evt_wait PROC
;;;26     
;;;27     OS_RESULT rt_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;28       /* Wait for one or more event flags with optional time-out.                */
;;;29       /* "wait_flags" identifies the flags to wait for.                          */
;;;30       /* "timeout" is the time-out limit in system ticks (0xffff if no time-out) */
;;;31       /* "and_wait" specifies the AND-ing of "wait_flags" as condition to be met */
;;;32       /* to complete the wait. (OR-ing if set to 0).                             */
;;;33       U32 block_state;
;;;34     
;;;35       if (and_wait) {
00000a  b1a7              CBZ      r7,|L1.54|
;;;36         /* Check for AND-connected events */
;;;37         if ((os_tsk.run->events & wait_flags) == wait_flags) {
00000c  4865              LDR      r0,|L1.420|
00000e  6800              LDR      r0,[r0,#0]  ; os_tsk
000010  8b00              LDRH     r0,[r0,#0x18]
000012  4020              ANDS     r0,r0,r4
000014  42a0              CMP      r0,r4
000016  d10b              BNE      |L1.48|
;;;38           os_tsk.run->events &= ~wait_flags;
000018  4862              LDR      r0,|L1.420|
00001a  6800              LDR      r0,[r0,#0]  ; os_tsk
00001c  8b00              LDRH     r0,[r0,#0x18]
00001e  ea200004          BIC      r0,r0,r4
000022  4960              LDR      r1,|L1.420|
000024  6809              LDR      r1,[r1,#0]  ; os_tsk
000026  8308              STRH     r0,[r1,#0x18]
;;;39           return (OS_R_EVT);
000028  f04f0002          MOV      r0,#2
                  |L1.44|
;;;40         }
;;;41         block_state = WAIT_AND;
;;;42       }
;;;43       else {
;;;44         /* Check for OR-connected events */
;;;45         if (os_tsk.run->events & wait_flags) {
;;;46           os_tsk.run->waits = os_tsk.run->events & wait_flags;
;;;47           os_tsk.run->events &= ~wait_flags;
;;;48           return (OS_R_EVT);
;;;49         }
;;;50         block_state = WAIT_OR;
;;;51       }
;;;52       /* Task has to wait */
;;;53       os_tsk.run->waits = wait_flags;
;;;54       rt_block (timeout, (U8)block_state);
;;;55       return (OS_R_TMO);
;;;56     }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.48|
000030  f04f0506          MOV      r5,#6                 ;41
000034  e019              B        |L1.106|
                  |L1.54|
000036  485b              LDR      r0,|L1.420|
000038  6800              LDR      r0,[r0,#0]            ;45  ; os_tsk
00003a  8b00              LDRH     r0,[r0,#0x18]         ;45
00003c  4220              TST      r0,r4                 ;45
00003e  d012              BEQ      |L1.102|
000040  4858              LDR      r0,|L1.420|
000042  6800              LDR      r0,[r0,#0]            ;46  ; os_tsk
000044  8b00              LDRH     r0,[r0,#0x18]         ;46
000046  ea000004          AND      r0,r0,r4              ;46
00004a  4956              LDR      r1,|L1.420|
00004c  6809              LDR      r1,[r1,#0]            ;46  ; os_tsk
00004e  8348              STRH     r0,[r1,#0x1a]         ;46
000050  4854              LDR      r0,|L1.420|
000052  6800              LDR      r0,[r0,#0]            ;47  ; os_tsk
000054  8b00              LDRH     r0,[r0,#0x18]         ;47
000056  ea200004          BIC      r0,r0,r4              ;47
00005a  4952              LDR      r1,|L1.420|
00005c  6809              LDR      r1,[r1,#0]            ;47  ; os_tsk
00005e  8308              STRH     r0,[r1,#0x18]         ;47
000060  f04f0002          MOV      r0,#2                 ;48
000064  e7e2              B        |L1.44|
                  |L1.102|
000066  f04f0505          MOV      r5,#5                 ;50
                  |L1.106|
00006a  484e              LDR      r0,|L1.420|
00006c  6800              LDR      r0,[r0,#0]            ;53  ; os_tsk
00006e  8344              STRH     r4,[r0,#0x1a]         ;53
000070  b2e9              UXTB     r1,r5                 ;54
000072  4630              MOV      r0,r6                 ;54
000074  f7fffffe          BL       rt_block
000078  2001              MOVS     r0,#1                 ;55
00007a  e7d7              B        |L1.44|
;;;57     
                          ENDP

                  rt_evt_set PROC
;;;60     
;;;61     void rt_evt_set (U16 event_flags, OS_TID task_id) {
00007c  b570              PUSH     {r4-r6,lr}
00007e  4605              MOV      r5,r0
000080  460e              MOV      r6,r1
;;;62       /* Set one or more event flags of a selectable task. */
;;;63       P_TCB p_tcb;
;;;64     
;;;65       p_tcb = os_active_TCB[task_id-1];
000082  f1a60001          SUB      r0,r6,#1
000086  4948              LDR      r1,|L1.424|
000088  f8510020          LDR      r0,[r1,r0,LSL #2]
00008c  4604              MOV      r4,r0
;;;66       if (p_tcb == NULL) {
00008e  b904              CBNZ     r4,|L1.146|
                  |L1.144|
;;;67         return;
;;;68       }
;;;69       p_tcb->events |= event_flags;
;;;70       event_flags    = p_tcb->waits;
;;;71       /* If the task is not waiting for an event, it should not be put */
;;;72       /* to ready state. */
;;;73       if (p_tcb->state == WAIT_AND) {
;;;74         /* Check for AND-connected events */
;;;75         if ((p_tcb->events & event_flags) == event_flags) {
;;;76           goto wkup;
;;;77         }
;;;78       }
;;;79       if (p_tcb->state == WAIT_OR) {
;;;80         /* Check for OR-connected events */
;;;81         if (p_tcb->events & event_flags) {
;;;82           p_tcb->waits  &= p_tcb->events;
;;;83     wkup: p_tcb->events &= ~event_flags;
;;;84           rt_rmv_dly (p_tcb);
;;;85           p_tcb->events &= ~event_flags;
;;;86           p_tcb->state   = READY;
;;;87           p_tcb->ret_val = OS_R_EVT;
;;;88           rt_dispatch (p_tcb);
;;;89         }
;;;90       }
;;;91     }
000090  bd70              POP      {r4-r6,pc}
                  |L1.146|
000092  8b20              LDRH     r0,[r4,#0x18]         ;69
000094  ea400005          ORR      r0,r0,r5              ;69
000098  8320              STRH     r0,[r4,#0x18]         ;69
00009a  8b60              LDRH     r0,[r4,#0x1a]         ;70
00009c  4605              MOV      r5,r0                 ;70
00009e  7860              LDRB     r0,[r4,#1]            ;73
0000a0  2806              CMP      r0,#6                 ;73
0000a2  d104              BNE      |L1.174|
0000a4  8b20              LDRH     r0,[r4,#0x18]         ;75
0000a6  4028              ANDS     r0,r0,r5              ;75
0000a8  42a8              CMP      r0,r5                 ;75
0000aa  d100              BNE      |L1.174|
0000ac  e00b              B        |L1.198|
                  |L1.174|
0000ae  7860              LDRB     r0,[r4,#1]            ;79
0000b0  2805              CMP      r0,#5                 ;79
0000b2  d11d              BNE      |L1.240|
0000b4  8b20              LDRH     r0,[r4,#0x18]         ;81
0000b6  4228              TST      r0,r5                 ;81
0000b8  d01a              BEQ      |L1.240|
0000ba  8b60              LDRH     r0,[r4,#0x1a]         ;82
0000bc  8b21              LDRH     r1,[r4,#0x18]         ;82
0000be  ea000001          AND      r0,r0,r1              ;82
0000c2  8360              STRH     r0,[r4,#0x1a]         ;82
0000c4  bf00              NOP                            ;83
                  |L1.198|
0000c6  8b20              LDRH     r0,[r4,#0x18]         ;83
0000c8  ea200005          BIC      r0,r0,r5              ;83
0000cc  8320              STRH     r0,[r4,#0x18]         ;83
0000ce  4620              MOV      r0,r4                 ;84
0000d0  f7fffffe          BL       rt_rmv_dly
0000d4  8b20              LDRH     r0,[r4,#0x18]         ;85
0000d6  ea200005          BIC      r0,r0,r5              ;85
0000da  8320              STRH     r0,[r4,#0x18]         ;85
0000dc  f04f0001          MOV      r0,#1                 ;86
0000e0  7060              STRB     r0,[r4,#1]            ;86
0000e2  f04f0002          MOV      r0,#2                 ;87
0000e6  f8840020          STRB     r0,[r4,#0x20]         ;87
0000ea  4620              MOV      r0,r4                 ;88
0000ec  f7fffffe          BL       rt_dispatch
                  |L1.240|
0000f0  bf00              NOP      
0000f2  e7cd              B        |L1.144|
;;;92     
                          ENDP

                  rt_evt_clr PROC
;;;95     
;;;96     void rt_evt_clr (U16 clear_flags, OS_TID task_id) {
0000f4  b510              PUSH     {r4,lr}
0000f6  4602              MOV      r2,r0
;;;97       /* Clear one or more event flags (identified by "clear_flags") of a */
;;;98       /* selectable task (identified by "task"). */
;;;99       P_TCB task = os_active_TCB[task_id-1];
0000f8  f1a10301          SUB      r3,r1,#1
0000fc  4c2a              LDR      r4,|L1.424|
0000fe  f8543023          LDR      r3,[r4,r3,LSL #2]
000102  4618              MOV      r0,r3
;;;100    
;;;101      if (task == NULL) {
000104  b900              CBNZ     r0,|L1.264|
                  |L1.262|
;;;102        return;
;;;103      }
;;;104      task->events &= ~clear_flags;
;;;105    }
000106  bd10              POP      {r4,pc}
                  |L1.264|
000108  8b03              LDRH     r3,[r0,#0x18]         ;104
00010a  ea230302          BIC      r3,r3,r2              ;104
00010e  8303              STRH     r3,[r0,#0x18]         ;104
000110  bf00              NOP      
000112  e7f8              B        |L1.262|
;;;106    
                          ENDP

                  isr_evt_set PROC
;;;109    
;;;110    void isr_evt_set (U16 event_flags, OS_TID task_id) {
000114  b570              PUSH     {r4-r6,lr}
000116  4604              MOV      r4,r0
000118  460e              MOV      r6,r1
;;;111      /* Same function as "os_evt_set", but to be called by ISRs. */
;;;112      P_TCB p_tcb = os_active_TCB[task_id-1];
00011a  f1a60001          SUB      r0,r6,#1
00011e  4922              LDR      r1,|L1.424|
000120  f8510020          LDR      r0,[r1,r0,LSL #2]
000124  4605              MOV      r5,r0
;;;113    
;;;114      if (p_tcb == NULL) {
000126  b905              CBNZ     r5,|L1.298|
                  |L1.296|
;;;115        return;
;;;116      }
;;;117      rt_psq_enq (p_tcb, event_flags);
;;;118      rt_psh_req ();
;;;119    }
000128  bd70              POP      {r4-r6,pc}
                  |L1.298|
00012a  4621              MOV      r1,r4                 ;117
00012c  4628              MOV      r0,r5                 ;117
00012e  f7fffffe          BL       rt_psq_enq
000132  f7fffffe          BL       rt_psh_req
000136  bf00              NOP      
000138  e7f6              B        |L1.296|
;;;120    
                          ENDP

                  rt_evt_get PROC
;;;123    
;;;124    U16 rt_evt_get (void) {
00013a  481a              LDR      r0,|L1.420|
;;;125      /* Get events of a running task after waiting for OR connected events. */
;;;126      return (os_tsk.run->waits);
00013c  6800              LDR      r0,[r0,#0]  ; os_tsk
00013e  8b40              LDRH     r0,[r0,#0x1a]
;;;127    }
000140  4770              BX       lr
;;;128    
                          ENDP

                  rt_evt_psh PROC
;;;131    
;;;132    void rt_evt_psh (P_TCB p_CB, U16 set_flags) {
000142  b570              PUSH     {r4-r6,lr}
000144  4604              MOV      r4,r0
000146  460e              MOV      r6,r1
;;;133      /* Check if task has to be waken up */
;;;134      U16 event_flags;
;;;135    
;;;136      p_CB->events |= set_flags;
000148  8b20              LDRH     r0,[r4,#0x18]
00014a  ea400006          ORR      r0,r0,r6
00014e  8320              STRH     r0,[r4,#0x18]
;;;137      event_flags = p_CB->waits;
000150  8b60              LDRH     r0,[r4,#0x1a]
000152  4605              MOV      r5,r0
;;;138      if (p_CB->state == WAIT_AND) {
000154  7860              LDRB     r0,[r4,#1]
000156  2806              CMP      r0,#6
000158  d104              BNE      |L1.356|
;;;139        /* Check for AND-connected events */
;;;140        if ((p_CB->events & event_flags) == event_flags) {
00015a  8b20              LDRH     r0,[r4,#0x18]
00015c  4028              ANDS     r0,r0,r5
00015e  42a8              CMP      r0,r5
000160  d100              BNE      |L1.356|
;;;141          goto rdy;
000162  e00b              B        |L1.380|
                  |L1.356|
;;;142        }
;;;143      }
;;;144      if (p_CB->state == WAIT_OR) {
000164  7860              LDRB     r0,[r4,#1]
000166  2805              CMP      r0,#5
000168  d11a              BNE      |L1.416|
;;;145        /* Check for OR-connected events */
;;;146        if (p_CB->events & event_flags) {
00016a  8b20              LDRH     r0,[r4,#0x18]
00016c  4228              TST      r0,r5
00016e  d017              BEQ      |L1.416|
;;;147          p_CB->waits  &= p_CB->events;
000170  8b60              LDRH     r0,[r4,#0x1a]
000172  8b21              LDRH     r1,[r4,#0x18]
000174  ea000001          AND      r0,r0,r1
000178  8360              STRH     r0,[r4,#0x1a]
;;;148    rdy:  p_CB->events &= ~event_flags;
00017a  bf00              NOP      
                  |L1.380|
00017c  8b20              LDRH     r0,[r4,#0x18]
00017e  ea200005          BIC      r0,r0,r5
000182  8320              STRH     r0,[r4,#0x18]
;;;149          rt_rmv_dly (p_CB);
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       rt_rmv_dly
;;;150          p_CB->state   = READY;
00018a  f04f0001          MOV      r0,#1
00018e  7060              STRB     r0,[r4,#1]
;;;151          p_CB->ret_val = OS_R_EVT;
000190  f04f0002          MOV      r0,#2
000194  f8840020          STRB     r0,[r4,#0x20]
;;;152          rt_put_prio (&os_rdy, p_CB);
000198  4621              MOV      r1,r4
00019a  4804              LDR      r0,|L1.428|
00019c  f7fffffe          BL       rt_put_prio
                  |L1.416|
;;;153        }
;;;154      }
;;;155    }
0001a0  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L1.420|
                          DCD      os_tsk
                  |L1.424|
                          DCD      os_active_TCB
                  |L1.428|
                          DCD      os_rdy
