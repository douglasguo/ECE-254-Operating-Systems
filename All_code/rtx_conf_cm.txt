; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -ortx_conf_cm.o --asm_dir=.\ --list_dir=.\ --depend=rtx_conf_cm.d --cpu=Cortex-M3 --apcs=interwork -O0 -IC:\Software\Keil\ARM\CMSIS\Include -IC:\Software\Keil\ARM\INC\NXP\LPC17xx --omf_browse=rtx_conf_cm.crf src\RTX_Conf_CM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  os_idle_demon PROC
;;;140    
;;;141    __task void os_idle_demon (void) {
000000  bf00              NOP      
                  |L1.2|
;;;142      /* The idle demon is a system task, running when no other task is ready */
;;;143      /* to run. The 'os_xxx' function calls are not allowed from this task.  */
;;;144    
;;;145      for (;;) {
000002  e7fe              B        |L1.2|
;;;146      /* HERE: include optional user code to be executed when no task runs.*/
;;;147      }
;;;148    }
;;;149    
                          ENDP

                  os_tmr_call PROC
;;;152    
;;;153    void os_tmr_call (U16 info) {
000004  4770              BX       lr
;;;154      /* This function is called when the user timer has expired. Parameter   */
;;;155      /* 'info' holds the value, defined when the timer was created.          */
;;;156    
;;;157      /* HERE: include optional user code to be executed on timeout. */
;;;158    }
;;;159    
                          ENDP

                  os_error PROC
;;;162    
;;;163    void os_error (U32 err_code) {
000006  bf00              NOP      
                  |L1.8|
;;;164      /* This function is called when a runtime error is detected. Parameter */
;;;165      /* 'err_code' holds the runtime error code (defined in RTL.H).         */
;;;166    
;;;167      /* HERE: include optional code to be executed on runtime error. */
;;;168      for (;;);
000008  e7fe              B        |L1.8|
;;;169    }
;;;170    
                          ENDP

                  __user_perthread_libspace PROC
;;;374    
;;;375    void *__user_perthread_libspace (void) {
00000a  b510              PUSH     {r4,lr}
;;;376      /* Provide a separate libspace for each task. */
;;;377      U32 idx;
;;;378    
;;;379      idx = runtask_id ();
00000c  f7fffffe          BL       rt_tsk_self
;;;380      if (idx == 0) {
000010  b130              CBZ      r0,|L1.32|
;;;381        /* RTX not running yet. */
;;;382        return (&__libspace_start);
;;;383      }
;;;384      return ((void *)&std_libspace[idx-1]);
000012  491a              LDR      r1,|L1.124|
000014  eb000040          ADD      r0,r0,r0,LSL #1
000018  eb011040          ADD      r0,r1,r0,LSL #5
00001c  3860              SUBS     r0,r0,#0x60
;;;385    }
00001e  bd10              POP      {r4,pc}
                  |L1.32|
000020  4817              LDR      r0,|L1.128|
000022  bd10              POP      {r4,pc}
;;;386    
                          ENDP

                  _mutex_initialize PROC
;;;388    
;;;389    int _mutex_initialize (OS_ID *mutex) {
000024  4a17              LDR      r2,|L1.132|
000026  b510              PUSH     {r4,lr}
;;;390      /* Allocate and initialize a system mutex. */
;;;391    
;;;392      if (nr_mutex >= OS_MUTEXCNT) {
000028  6851              LDR      r1,[r2,#4]  ; nr_mutex
00002a  2908              CMP      r1,#8
00002c  d300              BCC      |L1.48|
                  |L1.46|
;;;393        /* If you are here, you need to increase the number OS_MUTEXCNT. */
;;;394        for (;;);
00002e  e7fe              B        |L1.46|
                  |L1.48|
;;;395      }
;;;396      *mutex = &std_libmutex[nr_mutex++];
000030  eb010341          ADD      r3,r1,r1,LSL #1
000034  4c14              LDR      r4,|L1.136|
000036  1c49              ADDS     r1,r1,#1
000038  eb040383          ADD      r3,r4,r3,LSL #2
00003c  6003              STR      r3,[r0,#0]
00003e  4618              MOV      r0,r3
;;;397      mutex_init (*mutex);
000040  6051              STR      r1,[r2,#4]  ; nr_mutex
000042  f7fffffe          BL       rt_mut_init
;;;398      return (1);
000046  2001              MOVS     r0,#1
;;;399    }
000048  bd10              POP      {r4,pc}
;;;400    
                          ENDP

                  _mutex_acquire PROC
;;;403    
;;;404    void _mutex_acquire (OS_ID *mutex) {
00004a  b510              PUSH     {r4,lr}
00004c  4604              MOV      r4,r0
;;;405      /* Acquire a system mutex, lock stdlib resources. */
;;;406      if (runtask_id ()) {
00004e  f7fffffe          BL       rt_tsk_self
000052  2800              CMP      r0,#0
000054  d005              BEQ      |L1.98|
;;;407        /* RTX running, acquire a mutex. */
;;;408        mutex_wait (*mutex);
000056  f64f71ff          MOV      r1,#0xffff
00005a  f8dfc030          LDR      r12,|L1.140|
00005e  6820              LDR      r0,[r4,#0]
000060  df00              SVC      #0x0
                  |L1.98|
;;;409      }
;;;410    }
000062  bd10              POP      {r4,pc}
;;;411    
                          ENDP

                  _mutex_release PROC
;;;414    
;;;415    void _mutex_release (OS_ID *mutex) {
000064  b510              PUSH     {r4,lr}
000066  4604              MOV      r4,r0
;;;416      /* Release a system mutex, unlock stdlib resources. */
;;;417      if (runtask_id ()) {
000068  f7fffffe          BL       rt_tsk_self
00006c  2800              CMP      r0,#0
00006e  d003              BEQ      |L1.120|
;;;418        /* RTX runnning, release a mutex. */
;;;419        mutex_rel (*mutex);
000070  f8dfc01c          LDR      r12,|L1.144|
000074  6820              LDR      r0,[r4,#0]
000076  df00              SVC      #0x0
                  |L1.120|
;;;420      }
;;;421    }
000078  bd10              POP      {r4,pc}
;;;422    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      ||.bss||+0x200c
                  |L1.128|
                          DCD      __libspace_start
                  |L1.132|
                          DCD      ||.data||
                  |L1.136|
                          DCD      ||.bss||+0x224c
                  |L1.140|
                          DCD      rt_mut_wait
                  |L1.144|
                          DCD      rt_mut_release

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  mp_tcb
                          %        304
                  mp_stk
                          %        7744
                  os_fifo
                          %        132
                  os_active_TCB
                          %        24
                  std_libspace
                          %        576
                  std_libmutex
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  os_maxtaskrun
000000  0006              DCW      0x0006
000002  0000              DCB      0x00,0x00
                  os_stackinfo
                          DCD      0x0100044c
                  os_rrobin
                          DCD      0x00010005
                  os_trv
                          DCD      0x000f423f
                  os_flags
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  os_clockrate
                  ||__tagsym$$used||
                          DCD      0x00002710
                  os_timernum
                  |symbol_number.12|
                          DCD      0x00000000
                  mp_tcb_size
00001c  012c              DCW      0x012c
00001e  0000              DCB      0x00,0x00
                  mp_stk_size
                          DCD      0x00001e40
                  os_fifo_size
000024  1000              DCB      0x10,0x00
                  mp_tmr_size
000026  0000              DCW      0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  m_tmr
                          DCD      0x00000000
                  nr_mutex
                          DCD      0x00000000
