; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -ort_membox.o --asm_dir=.\ --list_dir=.\ --depend=rt_membox.d --cpu=Cortex-M3 --apcs=interwork -O0 -IC:\Software\Keil\ARM\CMSIS\Include -IC:\Software\Keil\ARM\INC\NXP\LPC17xx --omf_browse=rt_membox.crf rtx_src\rt_MemBox.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  _init_box PROC
;;;25     
;;;26     int _init_box  (void *box_mem, U32 box_size, U32 blk_size) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4603              MOV      r3,r0
000004  460e              MOV      r6,r1
;;;27       /* Initialize memory block system, returns 0 if OK, 1 if fails. */
;;;28       void *end;
;;;29       void *blk;
;;;30       void *next;
;;;31       U32  sizeof_bm;
;;;32     
;;;33       /* Create memory structure. */
;;;34       if (blk_size & BOX_ALIGN_8) {
000006  f0124f00          TST      r2,#0x80000000
00000a  d009              BEQ      |L1.32|
;;;35         /* Memory blocks 8-byte aligned. */ 
;;;36         blk_size = ((blk_size & ~BOX_ALIGN_8) + 7) & ~7;
00000c  f0224000          BIC      r0,r2,#0x80000000
000010  f1000007          ADD      r0,r0,#7
000014  f0200007          BIC      r0,r0,#7
000018  4602              MOV      r2,r0
;;;37         sizeof_bm = (sizeof (struct OS_BM) + 7) & ~7;
00001a  f04f0510          MOV      r5,#0x10
00001e  e006              B        |L1.46|
                  |L1.32|
;;;38       }
;;;39       else {
;;;40         /* Memory blocks 4-byte aligned. */
;;;41         blk_size = (blk_size + 3) & ~3;
000020  f1020003          ADD      r0,r2,#3
000024  f0200003          BIC      r0,r0,#3
000028  4602              MOV      r2,r0
;;;42         sizeof_bm = sizeof (struct OS_BM);
00002a  f04f050c          MOV      r5,#0xc
                  |L1.46|
;;;43       }
;;;44       if (blk_size == 0) {
00002e  b90a              CBNZ     r2,|L1.52|
;;;45         return (1);
000030  2001              MOVS     r0,#1
                  |L1.50|
;;;46       }
;;;47       if ((blk_size + sizeof_bm) > box_size) {
;;;48         return (1);
;;;49       }
;;;50       /* Create a Memory structure. */
;;;51       blk = ((U8 *) box_mem) + sizeof_bm;
;;;52       ((P_BM) box_mem)->free = blk;
;;;53       end = ((U8 *) box_mem) + box_size;
;;;54       ((P_BM) box_mem)->end      = end;
;;;55       ((P_BM) box_mem)->blk_size = blk_size;
;;;56     
;;;57       /* Link all free blocks using offsets. */
;;;58       end = ((U8 *) end) - blk_size;
;;;59       while (1)  {
;;;60         next = ((U8 *) blk) + blk_size;
;;;61         if (next > end)  break;
;;;62         *((void **)blk) = next;
;;;63         blk = next;
;;;64       }
;;;65       /* end marker */
;;;66       *((void **)blk) = 0;
;;;67       return (0);
;;;68     }
000032  bdf0              POP      {r4-r7,pc}
                  |L1.52|
000034  1950              ADDS     r0,r2,r5              ;47
000036  42b0              CMP      r0,r6                 ;47
000038  d901              BLS      |L1.62|
00003a  2001              MOVS     r0,#1                 ;48
00003c  e7f9              B        |L1.50|
                  |L1.62|
00003e  eb030105          ADD      r1,r3,r5              ;51
000042  6019              STR      r1,[r3,#0]            ;52
000044  eb030006          ADD      r0,r3,r6              ;53
000048  4607              MOV      r7,r0                 ;53
00004a  605f              STR      r7,[r3,#4]            ;54
00004c  609a              STR      r2,[r3,#8]            ;55
00004e  eba70002          SUB      r0,r7,r2              ;58
000052  4607              MOV      r7,r0                 ;58
000054  e006              B        |L1.100|
                  |L1.86|
000056  eb010402          ADD      r4,r1,r2              ;60
00005a  42bc              CMP      r4,r7                 ;61
00005c  d900              BLS      |L1.96|
00005e  e002              B        |L1.102|
                  |L1.96|
000060  600c              STR      r4,[r1,#0]            ;62
000062  4621              MOV      r1,r4                 ;63
                  |L1.100|
000064  e7f7              B        |L1.86|
                  |L1.102|
000066  bf00              NOP                            ;61
000068  f04f0000          MOV      r0,#0                 ;66
00006c  6008              STR      r0,[r1,#0]            ;66
00006e  bf00              NOP                            ;67
000070  e7df              B        |L1.50|
;;;69     
                          ENDP

                  rt_alloc_box PROC
;;;71     
;;;72     void *rt_alloc_box (void *box_mem) {
000072  4601              MOV      r1,r0
;;;73       /* Allocate a memory block and return start address. */
;;;74       void **free;
;;;75     #if !(defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
;;;76       int  irq_dis;
;;;77     
;;;78       irq_dis = __disable_irq ();
;;;79       free = ((P_BM) box_mem)->free;
;;;80       if (free) {
;;;81         ((P_BM) box_mem)->free = *free;
;;;82       }
;;;83       if (!irq_dis) __enable_irq ();
;;;84     #else
;;;85       do {
000074  bf00              NOP      
                  |L1.118|
;;;86         if ((free = (void **)__ldrex(&((P_BM) box_mem)->free)) == 0) {
000076  e8510f00          LDREX    r0,[r1,#0]
00007a  b910              CBNZ     r0,|L1.130|
;;;87           __clrex();
00007c  f3bf8f2f          CLREX    
;;;88           break;
000080  e004              B        |L1.140|
                  |L1.130|
;;;89         }
;;;90       } while (__strex((U32)*free, &((P_BM) box_mem)->free));
000082  6803              LDR      r3,[r0,#0]
000084  e8413200          STREX    r2,r3,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f4              BNE      |L1.118|
                  |L1.140|
00008c  bf00              NOP                            ;88
;;;91     #endif
;;;92       return (free);
;;;93     }
00008e  4770              BX       lr
;;;94     
                          ENDP

                  _calloc_box PROC
;;;97     
;;;98     void *_calloc_box (void *box_mem)  {
000090  e92d41f0          PUSH     {r4-r8,lr}
000094  4607              MOV      r7,r0
;;;99       /* Allocate a 0-initialized memory block and return start address. */
;;;100      void *free;
;;;101      U32 *p;
;;;102      U32 i;
;;;103    
;;;104      free = _alloc_box (box_mem);
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       _alloc_box
00009c  4604              MOV      r4,r0
;;;105      if (free)  {
00009e  b16c              CBZ      r4,|L1.188|
;;;106        p = free;
0000a0  4625              MOV      r5,r4
;;;107        for (i = ((P_BM) box_mem)->blk_size; i; i -= 4)  {
0000a2  68be              LDR      r6,[r7,#8]
0000a4  e008              B        |L1.184|
                  |L1.166|
;;;108          *p = 0;
0000a6  f04f0000          MOV      r0,#0
0000aa  6028              STR      r0,[r5,#0]
;;;109          p++;
0000ac  f1050004          ADD      r0,r5,#4
0000b0  4605              MOV      r5,r0
0000b2  f1a60004          SUB      r0,r6,#4              ;107
0000b6  4606              MOV      r6,r0                 ;107
                  |L1.184|
0000b8  2e00              CMP      r6,#0                 ;107
0000ba  d1f4              BNE      |L1.166|
                  |L1.188|
;;;110        }
;;;111      }
;;;112      return (free);
0000bc  4620              MOV      r0,r4
;;;113    }
0000be  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP

                  rt_free_box PROC
;;;117    
;;;118    int rt_free_box (void *box_mem, void *box) {
0000c2  4602              MOV      r2,r0
;;;119      /* Free a memory block, returns 0 if OK, 1 if box does not belong to box_mem */
;;;120    #if !(defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
;;;121      int irq_dis;
;;;122    #endif
;;;123    
;;;124      if (box < box_mem || box > ((P_BM) box_mem)->end) {
0000c4  4291              CMP      r1,r2
0000c6  d302              BCC      |L1.206|
0000c8  6850              LDR      r0,[r2,#4]
0000ca  4288              CMP      r0,r1
0000cc  d201              BCS      |L1.210|
                  |L1.206|
;;;125        return (1);
0000ce  2001              MOVS     r0,#1
                  |L1.208|
;;;126      }
;;;127    
;;;128    #if !(defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
;;;129      irq_dis = __disable_irq ();
;;;130      *((void **)box) = ((P_BM) box_mem)->free;
;;;131      ((P_BM) box_mem)->free = box;
;;;132      if (!irq_dis) __enable_irq ();
;;;133    #else
;;;134      do {
;;;135        *((void **)box) = (void *)__ldrex(&((P_BM) box_mem)->free);
;;;136      } while (__strex ((U32)box, &((P_BM) box_mem)->free));
;;;137    #endif
;;;138      return (0);
;;;139    }
0000d0  4770              BX       lr
                  |L1.210|
0000d2  bf00              NOP                            ;134
                  |L1.212|
0000d4  e8520f00          LDREX    r0,[r2,#0]            ;135
0000d8  6008              STR      r0,[r1,#0]            ;135
0000da  e8421000          STREX    r0,r1,[r2,#0]         ;136
0000de  2800              CMP      r0,#0                 ;136
0000e0  d1f8              BNE      |L1.212|
0000e2  bf00              NOP                            ;138
0000e4  e7f4              B        |L1.208|
;;;140    
                          ENDP

