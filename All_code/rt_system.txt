; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -ort_system.o --asm_dir=.\ --list_dir=.\ --depend=rt_system.d --cpu=Cortex-M3 --apcs=interwork -O0 -IC:\Software\Keil\ARM\CMSIS\Include -IC:\Software\Keil\ARM\INC\NXP\LPC17xx --omf_browse=rt_system.crf rtx_src\rt_System.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_tsk_lock PROC
;;;46     
;;;47     void rt_tsk_lock (void) {
000000  f04f0005          MOV      r0,#5
;;;48       /* Lock out tasks: prevents task switching by locking out scheduler */
;;;49       OS_LOCK();
000004  f04f21e0          MOV      r1,#0xe000e000
000008  6108              STR      r0,[r1,#0x10]
;;;50       os_lock = __TRUE;
00000a  f04f0001          MOV      r0,#1
00000e  4955              LDR      r1,|L1.356|
000010  7008              STRB     r0,[r1,#0]
;;;51     }
000012  4770              BX       lr
;;;52     
                          ENDP

                  rt_tsk_unlock PROC
;;;55     
;;;56     void rt_tsk_unlock (void) {
000014  f04f0007          MOV      r0,#7
;;;57       /* Enable System Tick Timer Interrupts. */
;;;58       OS_UNLOCK();
000018  f04f21e0          MOV      r1,#0xe000e000
00001c  6108              STR      r0,[r1,#0x10]
;;;59       os_lock = __FALSE;
00001e  f04f0000          MOV      r0,#0
000022  4950              LDR      r1,|L1.356|
000024  7008              STRB     r0,[r1,#0]
;;;60       if (os_psh_flag) {
000026  4850              LDR      r0,|L1.360|
000028  7800              LDRB     r0,[r0,#0]  ; os_psh_flag
00002a  b118              CBZ      r0,|L1.52|
;;;61         OS_PEND_IRQ ();
00002c  f04f5080          MOV      r0,#0x10000000
000030  494e              LDR      r1,|L1.364|
000032  6008              STR      r0,[r1,#0]
                  |L1.52|
;;;62       }
;;;63     }
000034  4770              BX       lr
;;;64     
                          ENDP

                  rt_psh_req PROC
;;;67     
;;;68     void rt_psh_req (void) {
000036  484b              LDR      r0,|L1.356|
;;;69       /* Initiate a post service handling request if required. */
;;;70       if (os_lock == __FALSE) {
000038  7800              LDRB     r0,[r0,#0]  ; os_lock
00003a  b920              CBNZ     r0,|L1.70|
;;;71         OS_PEND_IRQ ();
00003c  f04f5080          MOV      r0,#0x10000000
000040  494a              LDR      r1,|L1.364|
000042  6008              STR      r0,[r1,#0]
000044  e003              B        |L1.78|
                  |L1.70|
;;;72       }
;;;73       else {
;;;74         os_psh_flag = __TRUE;
000046  f04f0001          MOV      r0,#1
00004a  4947              LDR      r1,|L1.360|
00004c  7008              STRB     r0,[r1,#0]
                  |L1.78|
;;;75       }
;;;76     }
00004e  4770              BX       lr
;;;77     
                          ENDP

                  rt_pop_req PROC
;;;80     
;;;81     void rt_pop_req (void) {
000050  b570              PUSH     {r4-r6,lr}
;;;82       /* Process an ISR post service requests. */
;;;83       struct OS_XCB *p_CB;
;;;84       P_TCB next;
;;;85       U32  idx;
;;;86     
;;;87       os_tsk.run->state = READY;
000052  f04f0001          MOV      r0,#1
000056  4946              LDR      r1,|L1.368|
000058  6809              LDR      r1,[r1,#0]  ; os_tsk
00005a  7048              STRB     r0,[r1,#1]
;;;88       rt_put_rdy_first (os_tsk.run);
00005c  4944              LDR      r1,|L1.368|
00005e  6809              LDR      r1,[r1,#0]  ; os_tsk
000060  4608              MOV      r0,r1
000062  f7fffffe          BL       rt_put_rdy_first
;;;89     
;;;90       os_psh_flag = __FALSE;
000066  f04f0000          MOV      r0,#0
00006a  493f              LDR      r1,|L1.360|
00006c  7008              STRB     r0,[r1,#0]
;;;91       idx = os_psq->last;
00006e  4841              LDR      r0,|L1.372|
000070  7840              LDRB     r0,[r0,#1]  ; os_fifo
000072  4604              MOV      r4,r0
;;;92       while (os_psq->count) {
000074  e035              B        |L1.226|
                  |L1.118|
;;;93         p_CB = os_psq->q[idx].id;
000076  483f              LDR      r0,|L1.372|
000078  1d00              ADDS     r0,r0,#4
00007a  f8505034          LDR      r5,[r0,r4,LSL #3]
;;;94         if (p_CB->cb_type == TCB) {
00007e  7828              LDRB     r0,[r5,#0]
000080  b950              CBNZ     r0,|L1.152|
;;;95           /* Is of TCB type */
;;;96           rt_evt_psh ((P_TCB)p_CB, (U16)os_psq->q[idx].arg);
000082  483c              LDR      r0,|L1.372|
000084  1d00              ADDS     r0,r0,#4
000086  eb0000c4          ADD      r0,r0,r4,LSL #3
00008a  6840              LDR      r0,[r0,#4]
00008c  b280              UXTH     r0,r0
00008e  4601              MOV      r1,r0
000090  4628              MOV      r0,r5
000092  f7fffffe          BL       rt_evt_psh
000096  e00f              B        |L1.184|
                  |L1.152|
;;;97         }
;;;98         else if (p_CB->cb_type == MCB) {
000098  7828              LDRB     r0,[r5,#0]
00009a  2801              CMP      r0,#1
00009c  d109              BNE      |L1.178|
;;;99           /* Is of MCB type */
;;;100          rt_mbx_psh ((P_MCB)p_CB, (void *)os_psq->q[idx].arg);
00009e  4835              LDR      r0,|L1.372|
0000a0  1d00              ADDS     r0,r0,#4
0000a2  eb0000c4          ADD      r0,r0,r4,LSL #3
0000a6  6840              LDR      r0,[r0,#4]
0000a8  4601              MOV      r1,r0
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       rt_mbx_psh
0000b0  e002              B        |L1.184|
                  |L1.178|
;;;101        }
;;;102        else {
;;;103          /* Must be of SCB type */
;;;104          rt_sem_psh ((P_SCB)p_CB);
0000b2  4628              MOV      r0,r5
0000b4  f7fffffe          BL       rt_sem_psh
                  |L1.184|
;;;105        }
;;;106        if (++idx == os_psq->size) idx = 0;
0000b8  1c60              ADDS     r0,r4,#1
0000ba  4604              MOV      r4,r0
0000bc  492d              LDR      r1,|L1.372|
0000be  78c9              LDRB     r1,[r1,#3]  ; os_fifo
0000c0  4288              CMP      r0,r1
0000c2  d102              BNE      |L1.202|
0000c4  f04f0000          MOV      r0,#0
0000c8  4604              MOV      r4,r0
                  |L1.202|
;;;107        rt_dec (&os_psq->count);
0000ca  bf00              NOP      
                  |L1.204|
0000cc  4829              LDR      r0,|L1.372|
0000ce  1c80              ADDS     r0,r0,#2
0000d0  e8d00f4f          LDREXB   r0,[r0]
0000d4  1e40              SUBS     r0,r0,#1
0000d6  4927              LDR      r1,|L1.372|
0000d8  1c89              ADDS     r1,r1,#2
0000da  e8c10f42          STREXB   r2,r0,[r1]
0000de  2a00              CMP      r2,#0
0000e0  d1f4              BNE      |L1.204|
                  |L1.226|
0000e2  4824              LDR      r0,|L1.372|
0000e4  7880              LDRB     r0,[r0,#2]            ;92  ; os_fifo
0000e6  2800              CMP      r0,#0                 ;92
0000e8  d1c5              BNE      |L1.118|
;;;108      }
;;;109      os_psq->last = idx;
0000ea  4922              LDR      r1,|L1.372|
0000ec  704c              STRB     r4,[r1,#1]
;;;110    
;;;111      next = rt_get_first (&os_rdy);
0000ee  4822              LDR      r0,|L1.376|
0000f0  f7fffffe          BL       rt_get_first
0000f4  4606              MOV      r6,r0
;;;112      rt_switch_req (next);
0000f6  4630              MOV      r0,r6
0000f8  f7fffffe          BL       rt_switch_req
;;;113    }
0000fc  bd70              POP      {r4-r6,pc}
;;;114    
                          ENDP

                  rt_systick PROC
;;;117    
;;;118    void rt_systick (void) {
0000fe  b510              PUSH     {r4,lr}
;;;119      /* Check for system clock update, suspend running task. */
;;;120      P_TCB next;
;;;121    
;;;122      os_tsk.run->state = READY;
000100  f04f0001          MOV      r0,#1
000104  491a              LDR      r1,|L1.368|
000106  6809              LDR      r1,[r1,#0]  ; os_tsk
000108  7048              STRB     r0,[r1,#1]
;;;123      rt_put_rdy_first (os_tsk.run);
00010a  4919              LDR      r1,|L1.368|
00010c  6809              LDR      r1,[r1,#0]  ; os_tsk
00010e  4608              MOV      r0,r1
000110  f7fffffe          BL       rt_put_rdy_first
;;;124    
;;;125      /* Check Round Robin timeout. */
;;;126      rt_chk_robin ();
000114  f7fffffe          BL       rt_chk_robin
;;;127    
;;;128      /* Update delays. */
;;;129      os_time++;
000118  4818              LDR      r0,|L1.380|
00011a  8800              LDRH     r0,[r0,#0]  ; os_time
00011c  f1000001          ADD      r0,r0,#1
000120  4916              LDR      r1,|L1.380|
000122  8008              STRH     r0,[r1,#0]
;;;130      rt_dec_dly ();
000124  f7fffffe          BL       rt_dec_dly
;;;131    
;;;132      /* Check the user timers. */
;;;133      rt_tmr_tick ();
000128  f7fffffe          BL       rt_tmr_tick
;;;134    
;;;135      /* Switch back to highest ready task */
;;;136      next = rt_get_first (&os_rdy);
00012c  4812              LDR      r0,|L1.376|
00012e  f7fffffe          BL       rt_get_first
000132  4604              MOV      r4,r0
;;;137      rt_switch_req (next);
000134  4620              MOV      r0,r4
000136  f7fffffe          BL       rt_switch_req
;;;138    }
00013a  bd10              POP      {r4,pc}
;;;139    
                          ENDP

                  rt_stk_check PROC
;;;141    
;;;142    __weak void rt_stk_check (void) {
00013c  b510              PUSH     {r4,lr}
;;;143      /* Check for stack overflow. */
;;;144      if ((os_tsk.run->tsk_stack < (U32)os_tsk.run->stack) || 
00013e  480c              LDR      r0,|L1.368|
000140  6800              LDR      r0,[r0,#0]  ; os_tsk
000142  6a40              LDR      r0,[r0,#0x24]
000144  490a              LDR      r1,|L1.368|
000146  6809              LDR      r1,[r1,#0]  ; os_tsk
000148  6a89              LDR      r1,[r1,#0x28]
00014a  4288              CMP      r0,r1
00014c  d306              BCC      |L1.348|
;;;145          (os_tsk.run->stack[0] != MAGIC_WORD)) {
00014e  4808              LDR      r0,|L1.368|
000150  6800              LDR      r0,[r0,#0]  ; os_tsk
000152  6a80              LDR      r0,[r0,#0x28]
000154  6800              LDR      r0,[r0,#0]
000156  490a              LDR      r1,|L1.384|
000158  4288              CMP      r0,r1
00015a  d002              BEQ      |L1.354|
                  |L1.348|
;;;146        os_error (OS_ERR_STK_OVF);
00015c  2001              MOVS     r0,#1
00015e  f7fffffe          BL       os_error
                  |L1.354|
;;;147      }
;;;148    }
000162  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L1.356|
                          DCD      os_lock
                  |L1.360|
                          DCD      os_psh_flag
                  |L1.364|
                          DCD      0xe000ed04
                  |L1.368|
                          DCD      os_tsk
                  |L1.372|
                          DCD      os_fifo
                  |L1.376|
                          DCD      os_rdy
                  |L1.380|
                          DCD      os_time
                  |L1.384|
                          DCD      0xe25a2ea5

                          AREA ||.data||, DATA, ALIGN=0

                  os_lock
000000  00                DCB      0x00
                  os_psh_flag
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "rtx_src\\rt_System.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT ||$$RTX$$version||
#line 36
||$$RTX$$version|| PROC
#line 36

 

 EXPORT __RL_RTX_VER

__RL_RTX_VER EQU 0x420
	ENDP

;*** End   embedded assembler ***
