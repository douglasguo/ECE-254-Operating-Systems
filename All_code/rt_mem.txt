; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -ort_mem.o --asm_dir=.\ --list_dir=.\ --depend=rt_mem.d --cpu=Cortex-M3 --apcs=interwork -O0 -IC:\Software\Keil\ARM\CMSIS\Include -IC:\Software\Keil\ARM\INC\NXP\LPC17xx --omf_browse=rt_mem.crf rtx_src\rt_Mem.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  rt_init_mem PROC
;;;86      **/
;;;87     int rt_init_mem  (unsigned int addr_start, unsigned int addr_end)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;88     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;89       int memspace;
;;;90       int binaryend;
;;;91       _init_box (mpool, sizeof (mpool), sizeof (tree_node));
000008  f04f0214          MOV      r2,#0x14
00000c  f44f51a1          MOV      r1,#0x1420
000010  48ef              LDR      r0,|L1.976|
000012  f7fffffe          BL       _init_box
;;;92       _init_box (blockedArray, sizeof (blockedArray), sizeof (OS_TID));
000016  2204              MOVS     r2,#4
000018  2134              MOVS     r1,#0x34
00001a  48ee              LDR      r0,|L1.980|
00001c  f7fffffe          BL       _init_box
;;;93     
;;;94       blockedTasks = _calloc_box(blockedArray);
000020  48ec              LDR      r0,|L1.980|
000022  f7fffffe          BL       _calloc_box
000026  49ec              LDR      r1,|L1.984|
000028  6008              STR      r0,[r1,#0]  ; blockedTasks
;;;95       numBlocked = 0;
00002a  f04f0000          MOV      r0,#0
00002e  49eb              LDR      r1,|L1.988|
000030  6008              STR      r0,[r1,#0]  ; numBlocked
;;;96     
;;;97       root = _calloc_box (mpool);
000032  48e7              LDR      r0,|L1.976|
000034  f7fffffe          BL       _calloc_box
000038  49e9              LDR      r1,|L1.992|
00003a  6008              STR      r0,[r1,#0]  ; root
;;;98       
;;;99       root += 1;
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]  ; root
000040  f1000014          ADD      r0,r0,#0x14
000044  6008              STR      r0,[r1,#0]  ; root
;;;100      
;;;101      root->startloc = (void*) &Image$$RW_IRAM1$$ZI$$Limit;		 //get start of memory
000046  48e7              LDR      r0,|L1.996|
000048  6809              LDR      r1,[r1,#0]  ; root
00004a  6008              STR      r0,[r1,#0]
;;;102       memspace = (int)0x10008000 - (int)root->startloc;		//get available memory
00004c  48e4              LDR      r0,|L1.992|
00004e  6800              LDR      r0,[r0,#0]  ; root
000050  6800              LDR      r0,[r0,#0]
000052  49e5              LDR      r1,|L1.1000|
000054  eba10000          SUB      r0,r1,r0
000058  4604              MOV      r4,r0
;;;103      binaryend = memspace - memspace % MAXNUMBLOCKS;			//round available memory down to make sure it is  wholely divisible H times where H is height of binary tree
00005a  4620              MOV      r0,r4
00005c  ea4f71e4          ASR      r1,r4,#31
000060  eb046151          ADD      r1,r4,r1,LSR #25
000064  ea4f11e1          ASR      r1,r1,#7
000068  eba411c1          SUB      r1,r4,r1,LSL #7
00006c  eba40101          SUB      r1,r4,r1
000070  460d              MOV      r5,r1
;;;104      
;;;105      MINBLOCKSIZE = binaryend / MAXNUMBLOCKS;				   //calculate smallest possible block size 
000072  4628              MOV      r0,r5
000074  ea4f71e5          ASR      r1,r5,#31
000078  eb056151          ADD      r1,r5,r1,LSR #25
00007c  ea4f11e1          ASR      r1,r1,#7
000080  4ada              LDR      r2,|L1.1004|
000082  6011              STR      r1,[r2,#0]  ; MINBLOCKSIZE
;;;106      
;;;107    
;;;108      root->endloc = (void*)(binaryend + (int)root->startloc); //calculate our new end of memory based on above
000084  48d6              LDR      r0,|L1.992|
000086  6800              LDR      r0,[r0,#0]  ; root
000088  6800              LDR      r0,[r0,#0]
00008a  4428              ADD      r0,r0,r5
00008c  49d4              LDR      r1,|L1.992|
00008e  6809              LDR      r1,[r1,#0]  ; root
000090  6048              STR      r0,[r1,#4]
;;;109      root->left = 0;
000092  f04f0000          MOV      r0,#0
000096  49d2              LDR      r1,|L1.992|
000098  6809              LDR      r1,[r1,#0]  ; root
00009a  6088              STR      r0,[r1,#8]
;;;110      root->right = 0;
00009c  49d0              LDR      r1,|L1.992|
00009e  6809              LDR      r1,[r1,#0]  ; root
0000a0  60c8              STR      r0,[r1,#0xc]
;;;111      root->inuse = 0;
0000a2  49cf              LDR      r1,|L1.992|
0000a4  6809              LDR      r1,[r1,#0]  ; root
0000a6  7408              STRB     r0,[r1,#0x10]
;;;112      root->index = 1;
0000a8  f04f0001          MOV      r0,#1
0000ac  49cc              LDR      r1,|L1.992|
0000ae  6809              LDR      r1,[r1,#0]  ; root
0000b0  8248              STRH     r0,[r1,#0x12]
;;;113      
;;;114      initmem = 1;
0000b2  49cf              LDR      r1,|L1.1008|
0000b4  6008              STR      r0,[r1,#0]  ; initmem
;;;115      return 0;
0000b6  f04f0000          MOV      r0,#0
;;;116    }
0000ba  e8bd81f0          POP      {r4-r8,pc}
;;;117    
                          ENDP

                  allocate_block PROC
;;;152    
;;;153    void* allocate_block (tree_node *tree, int size, int treelevel)
0000be  e92d47f0          PUSH     {r4-r10,lr}
;;;154    {
0000c2  4604              MOV      r4,r0
0000c4  4688              MOV      r8,r1
0000c6  4617              MOV      r7,r2
;;;155    	int currsize;
;;;156    
;;;157    	void* returnvalue;
;;;158      tree_node *toaddleft;
;;;159      tree_node *toaddright;
;;;160      
;;;161    	currsize = MINBLOCKSIZE << (HEIGHT - treelevel);
0000c8  f1c70108          RSB      r1,r7,#8
0000cc  48c7              LDR      r0,|L1.1004|
0000ce  6800              LDR      r0,[r0,#0]  ; MINBLOCKSIZE
0000d0  fa00f001          LSL      r0,r0,r1
0000d4  4681              MOV      r9,r0
;;;162      
;;;163      if (size < MINBLOCKSIZE)
0000d6  48c5              LDR      r0,|L1.1004|
0000d8  6800              LDR      r0,[r0,#0]  ; MINBLOCKSIZE
0000da  4580              CMP      r8,r0
0000dc  da02              BGE      |L1.228|
;;;164      {
;;;165        size = MINBLOCKSIZE;
0000de  48c3              LDR      r0,|L1.1004|
0000e0  6800              LDR      r0,[r0,#0]  ; MINBLOCKSIZE
0000e2  4680              MOV      r8,r0
                  |L1.228|
;;;166      }
;;;167      
;;;168    	//first check if any children as can only allocate in leaves
;;;169    	if (tree->left != 0)
0000e4  68a0              LDR      r0,[r4,#8]
0000e6  b198              CBZ      r0,|L1.272|
;;;170    	{
;;;171    		returnvalue = allocate_block (tree->left, size, treelevel+1);
0000e8  68a1              LDR      r1,[r4,#8]
0000ea  4608              MOV      r0,r1
0000ec  1c7a              ADDS     r2,r7,#1
0000ee  4641              MOV      r1,r8
0000f0  f7fffffe          BL       allocate_block
0000f4  4682              MOV      r10,r0
;;;172    		
;;;173        if (returnvalue == 0)
0000f6  f1ba0f00          CMP      r10,#0
0000fa  d106              BNE      |L1.266|
;;;174    		{
;;;175    			returnvalue = allocate_block (tree->right, size,treelevel+1);
0000fc  68e1              LDR      r1,[r4,#0xc]
0000fe  4608              MOV      r0,r1
000100  1c7a              ADDS     r2,r7,#1
000102  4641              MOV      r1,r8
000104  f7fffffe          BL       allocate_block
000108  4682              MOV      r10,r0
                  |L1.266|
;;;176    		}
;;;177    		
;;;178        return returnvalue;
00010a  4650              MOV      r0,r10
                  |L1.268|
;;;179    	}
;;;180    	else
;;;181    	{
;;;182    		//no children we are in a leaf node check if it is of appropriate size
;;;183    		if (size <= currsize)
;;;184    		{
;;;185          if (size <= (currsize / 2))
;;;186          {
;;;187            //this block is too big compared to requested memory check
;;;188      			//check if it is in use and return 0 if it is if not
;;;189      			//create children to split block
;;;190      			
;;;191      			if (tree->inuse != 0)
;;;192      			{
;;;193      				return 0;
;;;194      			}
;;;195      			
;;;196      			//allocate memory for children
;;;197      			toaddleft = root + (tree->index << 1);
;;;198      			toaddright = root + (tree->index << 1) + 1;
;;;199      			
;;;200      			//create left child
;;;201      			toaddleft->left = 0;
;;;202      			toaddleft->right = 0;
;;;203      			toaddleft->inuse = 0;
;;;204      			toaddleft->startloc = tree->startloc;
;;;205      			toaddleft->endloc = (void*) ((((unsigned int) tree->endloc - (unsigned int) tree->startloc + 1) / 2) - 1 + (unsigned int) tree->startloc);
;;;206            toaddleft->index = (tree->index << 1);
;;;207      			
;;;208      			tree->left = toaddleft;
;;;209      			
;;;210      			//create right child
;;;211      			toaddright->left = 0;
;;;212      			toaddright->right = 0;
;;;213      			toaddright->inuse = 0;
;;;214      			toaddright->startloc = (void*) ((((unsigned int) tree->endloc - (unsigned int) tree->startloc + 1) / 2) + (unsigned int) tree->startloc);
;;;215      			toaddright->endloc = tree->endloc;
;;;216      			toaddright->index = (tree->index << 1) + 1;
;;;217            
;;;218      			tree->right = toaddright;
;;;219      			
;;;220      			//created children now attempt to allocate in one
;;;221      			return allocate_block (tree->left, size,treelevel + 1);
;;;222          }
;;;223          else
;;;224          {
;;;225            //right block size
;;;226      			//check if this memory is in use
;;;227      			if (tree->inuse)
;;;228      			{
;;;229      				return 0; //in use can't use this
;;;230      			}
;;;231      			else
;;;232      			{
;;;233      				//allocate memory
;;;234      				tree->inuse = 1;
;;;235              
;;;236      				return tree->startloc;
;;;237      			}
;;;238          }
;;;239        }
;;;240    		else
;;;241    		{
;;;242    			return 0; //no space in memory
;;;243    		}
;;;244    	}
;;;245    }
00010c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.272|
000110  45c8              CMP      r8,r9                 ;183
000112  dc5f              BGT      |L1.468|
000114  eb0971d9          ADD      r1,r9,r9,LSR #31      ;185
000118  ebb80f61          CMP      r8,r1,ASR #1          ;185
00011c  dc51              BGT      |L1.450|
00011e  7c20              LDRB     r0,[r4,#0x10]         ;191
000120  b108              CBZ      r0,|L1.294|
000122  2000              MOVS     r0,#0                 ;193
000124  e7f2              B        |L1.268|
                  |L1.294|
000126  8a60              LDRH     r0,[r4,#0x12]         ;197
000128  ea4f0040          LSL      r0,r0,#1              ;197
00012c  eb000080          ADD      r0,r0,r0,LSL #2       ;197
000130  49ab              LDR      r1,|L1.992|
000132  6809              LDR      r1,[r1,#0]            ;197  ; root
000134  eb010580          ADD      r5,r1,r0,LSL #2       ;197
000138  8a60              LDRH     r0,[r4,#0x12]         ;198
00013a  ea4f0040          LSL      r0,r0,#1              ;198
00013e  eb000080          ADD      r0,r0,r0,LSL #2       ;198
000142  49a7              LDR      r1,|L1.992|
000144  6809              LDR      r1,[r1,#0]            ;198  ; root
000146  eb010080          ADD      r0,r1,r0,LSL #2       ;198
00014a  f1000614          ADD      r6,r0,#0x14           ;198
00014e  f04f0000          MOV      r0,#0                 ;201
000152  60a8              STR      r0,[r5,#8]            ;201
000154  60e8              STR      r0,[r5,#0xc]          ;202
000156  7428              STRB     r0,[r5,#0x10]         ;203
000158  6820              LDR      r0,[r4,#0]            ;204
00015a  6028              STR      r0,[r5,#0]            ;204
00015c  e9d41000          LDRD     r1,r0,[r4,#0]         ;205
000160  eba00001          SUB      r0,r0,r1              ;205
000164  f1000001          ADD      r0,r0,#1              ;205
000168  f04f0101          MOV      r1,#1                 ;205
00016c  ebc10050          RSB      r0,r1,r0,LSR #1       ;205
000170  6821              LDR      r1,[r4,#0]            ;205
000172  4408              ADD      r0,r0,r1              ;205
000174  6068              STR      r0,[r5,#4]            ;205
000176  8a60              LDRH     r0,[r4,#0x12]         ;206
000178  ea4f4040          LSL      r0,r0,#17             ;206
00017c  ea4f4010          LSR      r0,r0,#16             ;206
000180  8268              STRH     r0,[r5,#0x12]         ;206
000182  60a5              STR      r5,[r4,#8]            ;208
000184  f04f0000          MOV      r0,#0                 ;211
000188  60b0              STR      r0,[r6,#8]            ;211
00018a  60f0              STR      r0,[r6,#0xc]          ;212
00018c  7430              STRB     r0,[r6,#0x10]         ;213
00018e  e9d41000          LDRD     r1,r0,[r4,#0]         ;214
000192  eba00001          SUB      r0,r0,r1              ;214
000196  f1000001          ADD      r0,r0,#1              ;214
00019a  eb010050          ADD      r0,r1,r0,LSR #1       ;214
00019e  6030              STR      r0,[r6,#0]            ;214
0001a0  6860              LDR      r0,[r4,#4]            ;215
0001a2  6070              STR      r0,[r6,#4]            ;215
0001a4  8a60              LDRH     r0,[r4,#0x12]         ;216
0001a6  f04f0101          MOV      r1,#1                 ;216
0001aa  eb010040          ADD      r0,r1,r0,LSL #1       ;216
0001ae  8270              STRH     r0,[r6,#0x12]         ;216
0001b0  60e6              STR      r6,[r4,#0xc]          ;218
0001b2  68a1              LDR      r1,[r4,#8]            ;221
0001b4  4608              MOV      r0,r1                 ;221
0001b6  f1070201          ADD      r2,r7,#1              ;221
0001ba  4641              MOV      r1,r8                 ;221
0001bc  f7fffffe          BL       allocate_block
0001c0  e7a4              B        |L1.268|
                  |L1.450|
0001c2  7c20              LDRB     r0,[r4,#0x10]         ;227
0001c4  b108              CBZ      r0,|L1.458|
0001c6  2000              MOVS     r0,#0                 ;229
0001c8  e7a0              B        |L1.268|
                  |L1.458|
0001ca  f04f0001          MOV      r0,#1                 ;234
0001ce  7420              STRB     r0,[r4,#0x10]         ;234
0001d0  6820              LDR      r0,[r4,#0]            ;236
0001d2  e79b              B        |L1.268|
                  |L1.468|
0001d4  2000              MOVS     r0,#0                 ;242
0001d6  e799              B        |L1.268|
;;;246    
                          ENDP

                  rt_mem_alloc PROC
;;;124     **/
;;;125    void* rt_mem_alloc (int size, unsigned char flag)
0001d8  e92d41f0          PUSH     {r4-r8,lr}
;;;126    {
0001dc  4606              MOV      r6,r0
0001de  460c              MOV      r4,r1
;;;127      void* startAddress = NULL;
0001e0  f04f0000          MOV      r0,#0
0001e4  4605              MOV      r5,r0
;;;128      OS_TID ID;
;;;129      
;;;130      if (!initmem ) //if memory has not been initialized we'd better do that
0001e6  4882              LDR      r0,|L1.1008|
0001e8  6800              LDR      r0,[r0,#0]  ; initmem
0001ea  b918              CBNZ     r0,|L1.500|
;;;131      {
;;;132        rt_init_mem(0,0);
0001ec  2100              MOVS     r1,#0
0001ee  4608              MOV      r0,r1
0001f0  f7fffffe          BL       rt_init_mem
                  |L1.500|
;;;133      }
;;;134      
;;;135      startAddress = allocate_block (root, size,1); //try and allocate requested memory
0001f4  2201              MOVS     r2,#1
0001f6  4631              MOV      r1,r6
0001f8  4879              LDR      r0,|L1.992|
0001fa  6800              LDR      r0,[r0,#0]  ; root
0001fc  f7fffffe          BL       allocate_block
000200  4605              MOV      r5,r0
;;;136      
;;;137      if (startAddress == 0 && flag) //unable to allocate memory and process wants to wait for memory
000202  b9b5              CBNZ     r5,|L1.562|
000204  b1ac              CBZ      r4,|L1.562|
;;;138      {
;;;139      	//store task id in blocked task array
;;;140        ID = rt_tsk_self();
000206  f7fffffe          BL       rt_tsk_self
00020a  4607              MOV      r7,r0
;;;141    	  blockedTasks[numBlocked]= ID;
00020c  4872              LDR      r0,|L1.984|
00020e  6800              LDR      r0,[r0,#0]  ; blockedTasks
000210  4972              LDR      r1,|L1.988|
000212  6809              LDR      r1,[r1,#0]  ; numBlocked
000214  f8407021          STR      r7,[r0,r1,LSL #2]
;;;142    	  numBlocked++;
000218  4870              LDR      r0,|L1.988|
00021a  6800              LDR      r0,[r0,#0]  ; numBlocked
00021c  f1000001          ADD      r0,r0,#1
000220  496e              LDR      r1,|L1.988|
000222  6008              STR      r0,[r1,#0]  ; numBlocked
;;;143      	rt_block(0xffff,INACTIVE);
000224  f04f0100          MOV      r1,#0
000228  f64f70ff          MOV      r0,#0xffff
00022c  f7fffffe          BL       rt_block
000230  e004              B        |L1.572|
                  |L1.562|
;;;144      }
;;;145      else if(startAddress ==0 && !flag) //no memory but not supposed to wait
000232  b91d              CBNZ     r5,|L1.572|
000234  b914              CBNZ     r4,|L1.572|
;;;146      {
;;;147      	return (void*)0;
000236  2000              MOVS     r0,#0
                  |L1.568|
;;;148      }
;;;149      
;;;150    	return startAddress;
;;;151    }
000238  e8bd81f0          POP      {r4-r8,pc}
                  |L1.572|
00023c  4628              MOV      r0,r5                 ;150
00023e  e7fb              B        |L1.568|
;;;152    
                          ENDP

                  cleanleaves PROC
;;;330     **/
;;;331    int cleanleaves(tree_node *tree)
000240  b5f0              PUSH     {r4-r7,lr}
;;;332    {
000242  4604              MOV      r4,r0
;;;333    	int flagLeft, flagRight;
;;;334    	int result = 0;
000244  f04f0000          MOV      r0,#0
000248  4607              MOV      r7,r0
;;;335    	
;;;336    	//if parent has both children with taskid of 0 delete them
;;;337    	
;;;338    	//first check if children exist
;;;339    	if (tree->left != 0)
00024a  68a0              LDR      r0,[r4,#8]
00024c  2800              CMP      r0,#0
00024e  d034              BEQ      |L1.698|
;;;340    	{
;;;341        //is left tree in use
;;;342        flagLeft = tree->left->inuse;
000250  68a0              LDR      r0,[r4,#8]
000252  7c05              LDRB     r5,[r0,#0x10]
;;;343        
;;;344        //left tree is not in use, does it have children
;;;345        if (flagLeft == 0)
000254  b945              CBNZ     r5,|L1.616|
;;;346        {
;;;347          flagLeft = (tree->left->left != 0);
000256  68a0              LDR      r0,[r4,#8]
000258  6880              LDR      r0,[r0,#8]
00025a  b110              CBZ      r0,|L1.610|
00025c  f04f0001          MOV      r0,#1
000260  e001              B        |L1.614|
                  |L1.610|
000262  f04f0000          MOV      r0,#0
                  |L1.614|
000266  4605              MOV      r5,r0
                  |L1.616|
;;;348        }
;;;349        
;;;350        //is right tree in use
;;;351        flagRight = tree->right->inuse;
000268  68e0              LDR      r0,[r4,#0xc]
00026a  7c06              LDRB     r6,[r0,#0x10]
;;;352        
;;;353        //right tree is not in use, does it have children
;;;354        if (flagRight == 0)
00026c  b946              CBNZ     r6,|L1.640|
;;;355        {
;;;356          flagRight = (tree->right->left != 0);
00026e  68e0              LDR      r0,[r4,#0xc]
000270  6880              LDR      r0,[r0,#8]
000272  b110              CBZ      r0,|L1.634|
000274  f04f0001          MOV      r0,#1
000278  e001              B        |L1.638|
                  |L1.634|
00027a  f04f0000          MOV      r0,#0
                  |L1.638|
00027e  4606              MOV      r6,r0
                  |L1.640|
;;;357        }
;;;358        
;;;359        //Dead tree, delete it
;;;360        if (flagLeft == 0 && flagRight == 0)
000280  b93d              CBNZ     r5,|L1.658|
000282  b936              CBNZ     r6,|L1.658|
;;;361        {
;;;362          tree->left = 0;
000284  f04f0000          MOV      r0,#0
000288  60a0              STR      r0,[r4,#8]
;;;363          tree->right = 0;
00028a  60e0              STR      r0,[r4,#0xc]
;;;364          
;;;365          return 1;
00028c  f04f0001          MOV      r0,#1
                  |L1.656|
;;;366        }
;;;367        else
;;;368        {
;;;369        	//Clean the trees that have children
;;;370    			if (tree->left->left != 0)
;;;371    	    {
;;;372        		result = cleanleaves (tree->left);
;;;373        	}
;;;374        	
;;;375        	if (tree->right->left != 0)
;;;376        	{
;;;377        		result = result | cleanleaves (tree->right);
;;;378    			}
;;;379    		  
;;;380    		  return result;
;;;381        }
;;;382    	}
;;;383    	else
;;;384    	{
;;;385    		return 0; 
;;;386      }
;;;387    }
000290  bdf0              POP      {r4-r7,pc}
                  |L1.658|
000292  68a0              LDR      r0,[r4,#8]            ;370
000294  6880              LDR      r0,[r0,#8]            ;370
000296  b120              CBZ      r0,|L1.674|
000298  68a1              LDR      r1,[r4,#8]            ;372
00029a  4608              MOV      r0,r1                 ;372
00029c  f7fffffe          BL       cleanleaves
0002a0  4607              MOV      r7,r0                 ;372
                  |L1.674|
0002a2  68e0              LDR      r0,[r4,#0xc]          ;375
0002a4  6880              LDR      r0,[r0,#8]            ;375
0002a6  b130              CBZ      r0,|L1.694|
0002a8  68e1              LDR      r1,[r4,#0xc]          ;377
0002aa  4608              MOV      r0,r1                 ;377
0002ac  f7fffffe          BL       cleanleaves
0002b0  ea400007          ORR      r0,r0,r7              ;377
0002b4  4607              MOV      r7,r0                 ;377
                  |L1.694|
0002b6  4638              MOV      r0,r7                 ;380
0002b8  e7ea              B        |L1.656|
                  |L1.698|
0002ba  2000              MOVS     r0,#0                 ;385
0002bc  e7e8              B        |L1.656|
;;;388    
                          ENDP

                  cleantree PROC
;;;314     **/
;;;315    int cleantree(tree_node *tree)
0002be  b530              PUSH     {r4,r5,lr}
;;;316    {
0002c0  4605              MOV      r5,r0
;;;317    	int cleancounter = 0;
0002c2  f04f0000          MOV      r0,#0
0002c6  4604              MOV      r4,r0
;;;318    	
;;;319    	while(cleanleaves(tree))
0002c8  e002              B        |L1.720|
                  |L1.714|
;;;320    	{
;;;321    		++cleancounter;
0002ca  f1040001          ADD      r0,r4,#1
0002ce  4604              MOV      r4,r0
                  |L1.720|
0002d0  4628              MOV      r0,r5                 ;319
0002d2  f7fffffe          BL       cleanleaves
0002d6  2800              CMP      r0,#0                 ;319
0002d8  d1f7              BNE      |L1.714|
;;;322    	}
;;;323    	
;;;324    	return cleancounter;
0002da  4620              MOV      r0,r4
;;;325    }
0002dc  bd30              POP      {r4,r5,pc}
;;;326    
                          ENDP

                  freeblock PROC
;;;290     **/
;;;291    int freeblock (tree_node *tree, void* startofmem)
0002de  b530              PUSH     {r4,r5,lr}
;;;292    {
0002e0  4604              MOV      r4,r0
0002e2  460d              MOV      r5,r1
;;;293      if (tree->left != 0)
0002e4  68a0              LDR      r0,[r4,#8]
0002e6  b178              CBZ      r0,|L1.776|
;;;294    	{
;;;295    		return (freeblock (tree->left, startofmem) || freeblock (tree->right, startofmem));
0002e8  68a1              LDR      r1,[r4,#8]
0002ea  4608              MOV      r0,r1
0002ec  4629              MOV      r1,r5
0002ee  f7fffffe          BL       freeblock
0002f2  b928              CBNZ     r0,|L1.768|
0002f4  68e1              LDR      r1,[r4,#0xc]
0002f6  4608              MOV      r0,r1
0002f8  4629              MOV      r1,r5
0002fa  f7fffffe          BL       freeblock
0002fe  b108              CBZ      r0,|L1.772|
                  |L1.768|
000300  2001              MOVS     r0,#1
                  |L1.770|
;;;296    	}
;;;297    	else //no children must be in leaf node
;;;298    	{
;;;299    		if (tree->startloc == startofmem)
;;;300    		{
;;;301    			tree->inuse = 0;
;;;302    			return 1;
;;;303    		}
;;;304    		else
;;;305    		{
;;;306    			return 0;
;;;307    		}
;;;308    	}
;;;309    }
000302  bd30              POP      {r4,r5,pc}
                  |L1.772|
000304  2000              MOVS     r0,#0                 ;295
000306  e7fc              B        |L1.770|
                  |L1.776|
000308  6820              LDR      r0,[r4,#0]            ;299
00030a  42a8              CMP      r0,r5                 ;299
00030c  d105              BNE      |L1.794|
00030e  f04f0000          MOV      r0,#0                 ;301
000312  7420              STRB     r0,[r4,#0x10]         ;301
000314  f04f0001          MOV      r0,#1                 ;302
000318  e7f3              B        |L1.770|
                  |L1.794|
00031a  2000              MOVS     r0,#0                 ;306
00031c  e7f1              B        |L1.770|
;;;310    
                          ENDP

                  rt_mem_free PROC
;;;252     **/
;;;253    int rt_mem_free (void* ptr)
00031e  e92d41f0          PUSH     {r4-r8,lr}
;;;254    {
000322  4607              MOV      r7,r0
;;;255      int result;
;;;256      int taskOn;
;;;257      P_TCB taskContext;
;;;258      
;;;259      if (!initmem ) //if silly programmer tries to free mem before allocating it 
000324  4832              LDR      r0,|L1.1008|
000326  6800              LDR      r0,[r0,#0]  ; initmem
000328  b918              CBNZ     r0,|L1.818|
;;;260      {
;;;261        return -1;
00032a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.814|
;;;262      }
;;;263      
;;;264      result = freeblock(root,ptr);
;;;265      
;;;266      cleantree(root);
;;;267      
;;;268      if(result) //if some memory has been freed try to allocate this memory to any tasks waiting for memory
;;;269      {
;;;270        for (taskOn = 0; taskOn < numBlocked; taskOn++)
;;;271    	  {
;;;272    		  //some memory has been freed dispatch all tasks to try and allocate memory	
;;;273    			//set task into ready state and change its return value
;;;274    
;;;275    			taskContext = os_active_TCB[blockedTasks[taskOn] - 1];
;;;276    			taskContext->state = READY;
;;;277          rt_put_prio(&os_rdy,taskContext);
;;;278    	  }
;;;279          
;;;280    	  numBlocked = 0;
;;;281      }  
;;;282      
;;;283      //Note: To handle recursion the actual free algorithm returns 0 and 1 respectively.
;;;284      return (--result);
;;;285    }
00032e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.818|
000332  4639              MOV      r1,r7                 ;264
000334  482a              LDR      r0,|L1.992|
000336  6800              LDR      r0,[r0,#0]            ;264  ; root
000338  f7fffffe          BL       freeblock
00033c  4605              MOV      r5,r0                 ;264
00033e  4828              LDR      r0,|L1.992|
000340  6800              LDR      r0,[r0,#0]            ;266  ; root
000342  f7fffffe          BL       cleantree
000346  b1ed              CBZ      r5,|L1.900|
000348  f04f0400          MOV      r4,#0                 ;270
00034c  e012              B        |L1.884|
                  |L1.846|
00034e  4822              LDR      r0,|L1.984|
000350  6800              LDR      r0,[r0,#0]            ;275  ; blockedTasks
000352  f8500024          LDR      r0,[r0,r4,LSL #2]     ;275
000356  f1a00001          SUB      r0,r0,#1              ;275
00035a  4926              LDR      r1,|L1.1012|
00035c  f8516020          LDR      r6,[r1,r0,LSL #2]     ;275
000360  f04f0001          MOV      r0,#1                 ;276
000364  7070              STRB     r0,[r6,#1]            ;276
000366  4631              MOV      r1,r6                 ;277
000368  4823              LDR      r0,|L1.1016|
00036a  f7fffffe          BL       rt_put_prio
00036e  f1040001          ADD      r0,r4,#1              ;270
000372  4604              MOV      r4,r0                 ;270
                  |L1.884|
000374  4819              LDR      r0,|L1.988|
000376  6800              LDR      r0,[r0,#0]            ;270  ; numBlocked
000378  4284              CMP      r4,r0                 ;270
00037a  dbe8              BLT      |L1.846|
00037c  f04f0000          MOV      r0,#0                 ;280
000380  4916              LDR      r1,|L1.988|
000382  6008              STR      r0,[r1,#0]            ;280  ; numBlocked
                  |L1.900|
000384  1e68              SUBS     r0,r5,#1              ;284
000386  4605              MOV      r5,r0                 ;284
000388  e7d1              B        |L1.814|
;;;286    
                          ENDP

                  print_tree PROC
;;;393     **/
;;;394    void print_tree (tree_node* tree)
00038a  b538              PUSH     {r3-r5,lr}
;;;395    {
00038c  4604              MOV      r4,r0
;;;396     	if(tree->left)
00038e  68a0              LDR      r0,[r4,#8]
000390  b118              CBZ      r0,|L1.922|
;;;397      {
;;;398        print_tree (tree->left);
000392  68a1              LDR      r1,[r4,#8]
000394  4608              MOV      r0,r1
000396  f7fffffe          BL       print_tree
                  |L1.922|
;;;399      }
;;;400      
;;;401      printf ("StartLocation: %d | EndLocation: %d | In Use: %d | Array Position: %d \n", ((unsigned int) tree->startloc - (unsigned int)root->startloc) , ((unsigned int) tree->endloc - (unsigned int)root->startloc), tree->inuse, tree->index);
00039a  8a60              LDRH     r0,[r4,#0x12]
00039c  9000              STR      r0,[sp,#0]
00039e  4d10              LDR      r5,|L1.992|
0003a0  6860              LDR      r0,[r4,#4]
0003a2  682d              LDR      r5,[r5,#0]  ; root
0003a4  682d              LDR      r5,[r5,#0]
0003a6  1b40              SUBS     r0,r0,r5
0003a8  4602              MOV      r2,r0
0003aa  4d0d              LDR      r5,|L1.992|
0003ac  6820              LDR      r0,[r4,#0]
0003ae  682d              LDR      r5,[r5,#0]  ; root
0003b0  682d              LDR      r5,[r5,#0]
0003b2  1b40              SUBS     r0,r0,r5
0003b4  4601              MOV      r1,r0
0003b6  7c20              LDRB     r0,[r4,#0x10]
0003b8  4603              MOV      r3,r0
0003ba  4810              LDR      r0,|L1.1020|
0003bc  f7fffffe          BL       __2printf
;;;402      
;;;403      if(tree->right)
0003c0  68e0              LDR      r0,[r4,#0xc]
0003c2  b118              CBZ      r0,|L1.972|
;;;404      {
;;;405        print_tree (tree->right);
0003c4  68e1              LDR      r1,[r4,#0xc]
0003c6  4608              MOV      r0,r1
0003c8  f7fffffe          BL       print_tree
                  |L1.972|
;;;406      }
;;;407    }
0003cc  bd38              POP      {r3-r5,pc}
;;;408    
                          ENDP

0003ce  0000              DCW      0x0000
                  |L1.976|
                          DCD      mpool
                  |L1.980|
                          DCD      blockedArray
                  |L1.984|
                          DCD      blockedTasks
                  |L1.988|
                          DCD      numBlocked
                  |L1.992|
                          DCD      root
                  |L1.996|
                          DCD      ||Image$$RW_IRAM1$$ZI$$Limit||
                  |L1.1000|
                          DCD      0x10008000
                  |L1.1004|
                          DCD      MINBLOCKSIZE
                  |L1.1008|
                          DCD      initmem
                  |L1.1012|
                          DCD      os_active_TCB
                  |L1.1016|
                          DCD      os_rdy
                  |L1.1020|
                          DCD      ||.constdata||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mpool
                          %        5152
                  blockedArray
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  53746172          DCB      0x53,0x74,0x61,0x72
000004  744c6f63          DCB      0x74,0x4c,0x6f,0x63
000008  6174696f          DCB      0x61,0x74,0x69,0x6f
00000c  6e3a2025          DCB      0x6e,0x3a,0x20,0x25
000010  64207c20          DCB      0x64,0x20,0x7c,0x20
000014  456e644c          DCB      0x45,0x6e,0x64,0x4c
000018  6f636174          DCB      0x6f,0x63,0x61,0x74
00001c  696f6e3a          DCB      0x69,0x6f,0x6e,0x3a
000020  20256420          DCB      0x20,0x25,0x64,0x20
000024  7c20496e          DCB      0x7c,0x20,0x49,0x6e
000028  20557365          DCB      0x20,0x55,0x73,0x65
00002c  3a202564          DCB      0x3a,0x20,0x25,0x64
000030  207c2041          DCB      0x20,0x7c,0x20,0x41
000034  72726179          DCB      0x72,0x72,0x61,0x79
000038  20506f73          DCB      0x20,0x50,0x6f,0x73
00003c  6974696f          DCB      0x69,0x74,0x69,0x6f
000040  6e3a2025          DCB      0x6e,0x3a,0x20,0x25
000044  64200a00          DCB      0x64,0x20,0x0a,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  initmem
                          DCD      0x00000000
                  MINBLOCKSIZE
                          DCD      0x00000000
                  root
                          DCD      0x00000000
                  blockedTasks
                          DCD      0x00000000
                  numBlocked
                          DCD      0x00000000
