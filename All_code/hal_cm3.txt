; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -ohal_cm3.o --asm_dir=.\ --list_dir=.\ --depend=hal_cm3.d --cpu=Cortex-M3 --apcs=interwork -O0 -IC:\Software\Keil\ARM\CMSIS\Include -IC:\Software\Keil\ARM\INC\NXP\LPC17xx --omf_browse=hal_cm3.crf rtx_src\HAL_CM3.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_init_stack PROC
;;;217    
;;;218    void rt_init_stack (P_TCB p_TCB, FUNCP task_body) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;219      /* Prepare TCB and saved context for a first time start of a task. */
;;;220      U32 *stk,i,size;
;;;221    
;;;222      /* Prepare a complete interrupt frame for first task start */
;;;223      size = p_TCB->priv_stack >> 2;
000006  8c55              LDRH     r5,[r2,#0x22]
000008  ea4f05a5          ASR      r5,r5,#2
00000c  462c              MOV      r4,r5
;;;224      if (size == 0) {
00000e  b924              CBNZ     r4,|L1.26|
;;;225        size = (U16)os_stackinfo >> 2;
000010  4d2e              LDR      r5,|L1.204|
000012  682d              LDR      r5,[r5,#0]  ; os_stackinfo
000014  f3c5058d          UBFX     r5,r5,#2,#14
000018  462c              MOV      r4,r5
                  |L1.26|
;;;226      }
;;;227    
;;;228      /* Write to the top of stack. */
;;;229      stk = &p_TCB->stack[size];
00001a  6a95              LDR      r5,[r2,#0x28]
00001c  eb050084          ADD      r0,r5,r4,LSL #2
;;;230    
;;;231      /* Auto correct to 8-byte ARM stack alignment. */
;;;232      if ((U32)stk & 0x04) {
000020  f0100f04          TST      r0,#4
000024  d002              BEQ      |L1.44|
;;;233        stk--;
000026  f1a00504          SUB      r5,r0,#4
00002a  4628              MOV      r0,r5
                  |L1.44|
;;;234      }
;;;235    
;;;236      stk -= 16;
00002c  f1a00540          SUB      r5,r0,#0x40
000030  4628              MOV      r0,r5
;;;237    
;;;238      /* Default xPSR and initial PC */
;;;239      stk[15] = INITIAL_xPSR;
000032  f04f7580          MOV      r5,#0x1000000
000036  63c5              STR      r5,[r0,#0x3c]
;;;240      stk[14] = (U32)task_body;
000038  6383              STR      r3,[r0,#0x38]
;;;241    
;;;242      /* Clear R1-R12,LR registers. */
;;;243      for (i = 0; i < 14; i++) {
00003a  f04f0100          MOV      r1,#0
00003e  e006              B        |L1.78|
                  |L1.64|
;;;244        stk[i] = 0;
000040  f04f0500          MOV      r5,#0
000044  f8405021          STR      r5,[r0,r1,LSL #2]
000048  f1010501          ADD      r5,r1,#1              ;243
00004c  4629              MOV      r1,r5                 ;243
                  |L1.78|
00004e  290e              CMP      r1,#0xe               ;243
000050  d3f6              BCC      |L1.64|
;;;245      }
;;;246    
;;;247      /* Assign a void pointer to R0. */
;;;248      stk[8] = (U32)p_TCB->msg;
000052  69d5              LDR      r5,[r2,#0x1c]
000054  6205              STR      r5,[r0,#0x20]
;;;249    
;;;250      /* Initial Task stack pointer. */
;;;251      p_TCB->tsk_stack = (U32)stk;
000056  6250              STR      r0,[r2,#0x24]
;;;252    
;;;253      /* Task entry point. */
;;;254      p_TCB->ptask = task_body;
000058  62d3              STR      r3,[r2,#0x2c]
;;;255    
;;;256      /* Set a magic word for checking of stack overflow. */
;;;257      p_TCB->stack[0] = MAGIC_WORD;
00005a  4d1d              LDR      r5,|L1.208|
00005c  6a96              LDR      r6,[r2,#0x28]
00005e  6035              STR      r5,[r6,#0]
;;;258    }
000060  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP

                  dbg_init PROC
;;;262    
;;;263    void dbg_init (void) {
000062  481c              LDR      r0,|L1.212|
;;;264      if ((DEMCR & DEMCR_TRCENA)     && 
000064  6800              LDR      r0,[r0,#0]
000066  f0107f80          TST      r0,#0x1000000
00006a  d00e              BEQ      |L1.138|
;;;265          (ITM_CONTROL & ITM_ITMENA) &&
00006c  481a              LDR      r0,|L1.216|
00006e  6800              LDR      r0,[r0,#0]
000070  f0100f01          TST      r0,#1
000074  d009              BEQ      |L1.138|
;;;266          (ITM_ENABLE & (1UL << 31))) {
000076  4818              LDR      r0,|L1.216|
000078  3880              SUBS     r0,r0,#0x80
00007a  6800              LDR      r0,[r0,#0]
00007c  f0104f00          TST      r0,#0x80000000
000080  d003              BEQ      |L1.138|
;;;267        dbg_msg = __TRUE;
000082  f04f0001          MOV      r0,#1
000086  4915              LDR      r1,|L1.220|
000088  7008              STRB     r0,[r1,#0]
                  |L1.138|
;;;268      }
;;;269    }
00008a  4770              BX       lr
;;;270    
                          ENDP

                  dbg_task_notify PROC
;;;273    
;;;274    void dbg_task_notify (P_TCB p_tcb, BOOL create) {
00008c  bf00              NOP      
                  |L1.142|
;;;275      while (ITM_PORT31_U32 == 0);
00008e  f04f4260          MOV      r2,#0xe0000000
000092  6fd2              LDR      r2,[r2,#0x7c]
000094  2a00              CMP      r2,#0
000096  d0fa              BEQ      |L1.142|
;;;276      ITM_PORT31_U32 = (U32)p_tcb->ptask;
000098  f04f4360          MOV      r3,#0xe0000000
00009c  6ac2              LDR      r2,[r0,#0x2c]
00009e  67da              STR      r2,[r3,#0x7c]
;;;277      while (ITM_PORT31_U32 == 0);
0000a0  bf00              NOP      
                  |L1.162|
0000a2  f04f4260          MOV      r2,#0xe0000000
0000a6  6fd2              LDR      r2,[r2,#0x7c]
0000a8  2a00              CMP      r2,#0
0000aa  d0fa              BEQ      |L1.162|
;;;278      ITM_PORT31_U16 = (create << 8) | p_tcb->task_id;
0000ac  78c2              LDRB     r2,[r0,#3]
0000ae  ea422201          ORR      r2,r2,r1,LSL #8
0000b2  4b0b              LDR      r3,|L1.224|
0000b4  801a              STRH     r2,[r3,#0]
;;;279    }
0000b6  4770              BX       lr
;;;280    
                          ENDP

                  dbg_task_switch PROC
;;;283    
;;;284    void dbg_task_switch (U32 task_id) {
0000b8  bf00              NOP      
                  |L1.186|
;;;285      while (ITM_PORT31_U32 == 0);
0000ba  f04f4160          MOV      r1,#0xe0000000
0000be  6fc9              LDR      r1,[r1,#0x7c]
0000c0  2900              CMP      r1,#0
0000c2  d0fa              BEQ      |L1.186|
;;;286      ITM_PORT31_U8 = task_id;
0000c4  4a06              LDR      r2,|L1.224|
0000c6  7010              STRB     r0,[r2,#0]
;;;287    }
0000c8  4770              BX       lr
;;;288    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L1.204|
                          DCD      os_stackinfo
                  |L1.208|
                          DCD      0xe25a2ea5
                  |L1.212|
                          DCD      0xe000edfc
                  |L1.216|
                          DCD      0xe0000e80
                  |L1.220|
                          DCD      dbg_msg
                  |L1.224|
                          DCD      0xe000007c

                          AREA ||.data||, DATA, ALIGN=0

                  dbg_msg
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "rtx_src\\HAL_CM3.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |rt_set_PSP|
#line 34
|rt_set_PSP| PROC
#line 34

 MSR PSP,R0
 BX LR
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |os_set_env|
	IMPORT |os_flags|
#line 42
|os_set_env| PROC
#line 42

 
 MOV R0,SP 
 MSR PSP,R0
 LDR R0,= |os_flags|
 LDRB R0,[R0]
 LSLS R0,#31
 MOVNE R0,#0x02 
 MOVEQ R0,#0x03 
 MSR CONTROL,R0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |_alloc_box|
	IMPORT |rt_alloc_box|
#line 60
|_alloc_box| PROC
#line 60

 
 LDR R12,= |rt_alloc_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |_free_box|
	IMPORT |rt_free_box|
#line 78
|_free_box| PROC
#line 78

 
 LDR R12,= |rt_free_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |SVC_Handler|
	IMPORT |os_tsk|
#line 96
|SVC_Handler| PROC
#line 96

 PRESERVE8

 IMPORT SVC_Count
 IMPORT SVC_Table
 IMPORT rt_stk_check

 MRS R0,PSP 
 LDR R1,[R0,#24] 
 LDRH R1,[R1,#-2] 
 BICS R1,R1,#0xFF00 
 BNE SVC_User

 LDM R0,{R0-R3,R12} 
 BLX R12 

 MRS R12,PSP 
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ SVC_Exit 

 PUSH {R2,R3}
 MOV R3,#1
 CMP R1,#0 
 STRBNE R3,[R1,#33] 
 STMDBNE R12!,{R4-R11} 
 STRNE R12,[R1,#36] 
 BLNE rt_stk_check 

 POP {R2,R3}
 STR R2,[R3] 

 LDR R12,[R2,#36] 
 LDMIA R12!,{R4-R11} 
 LDRH R3,[R2,#33] 
 MSR PSP,R12 

 CBZ R3,SVC_Return
 LDRB R0,[R2,#32] 

SVC_Exit
 STR R0,[R12] 

SVC_Return
 MVN LR,#:NOT:0xFFFFFFFD 
 BX LR

 

SVC_User
 PUSH {R4,LR} 
 LDR R2,=SVC_Count
 LDR R2,[R2]
 CMP R1,R2
 BHI SVC_Done 

 LDR R4,=SVC_Table-4
 LDR R4,[R4,R1,LSL #2] 

 LDM R0,{R0-R3,R12} 
 BLX R4 

 MRS R12,PSP
 STM R12,{R0-R3} 
SVC_Done
 POP {R4,PC} 

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |Sys_Handler|
	IMPORT |rt_pop_req|
	IMPORT |rt_systick|
#line 170
|Sys_Handler| PROC
#line 170

 PRESERVE8

 EXPORT SysTick_Handler
 EXPORT PendSV_Handler

PendSV_Handler
 BL  |rt_pop_req|

Sys_Switch
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ SysExit

 PUSH {R2,R3}
 MOV R3,#0
 STRB R3,[R1,#33] 
 MRS R12,PSP 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#36] 
 BL rt_stk_check 

 POP {R2,R3}
 STR R2,[R3] 

 LDR R12,[R2,#36] 
 LDMIA R12!,{R4-R11} 
 MSR PSP,R12 

 LDRB R3,[R2,#33] 
 CBZ R3,SysExit
 LDRB R3,[R2,#32] 
 STR R3,[R12]
SysExit
 MVN LR,#:NOT:0xFFFFFFFD 
 BX LR 

SysTick_Handler
 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP

;*** End   embedded assembler ***
